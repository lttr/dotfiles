#!/usr/bin/env zsh
#    __                      _    _                    
#   / _| _   _  _ __    ___ | |_ (_)  ___   _ __   ___ 
#  | |_ | | | || '_ \  / __|| __|| | / _ \ | '_ \ / __|
#  |  _|| |_| || | | || (__ | |_ | || (_) || | | |\__ \
#  |_|   \__,_||_| |_| \___| \__||_| \___/ |_| |_||___/
#                                                      


# =================================================================
#                            Packages
# =================================================================

apt-list() {
    comm -23 <( apt-mark showmanual | sort -u ) <( gzip -dc /var/log/installer/initial-status.gz | sed -n 's/^Package: //p' | sort -u )
}


# =================================================================
#                          Dictionaries
# =================================================================

# Try to find word in dictionary, remove clutter from output

aj() {
    dict -d fd-eng-ces "$1" | grep -v '^From ' | grep -v '^$' | grep -v '[0-9] def' | grep -v "$1" | sed 's/()//'
}

cz() {
    dict -d fd-ces-eng "$1" | grep -v '^From ' | grep -v '^$' | sed 's/()//'
}

eng() {
    dict -d gcide "$1" | grep -v '^From ' | grep -v '^$' | sed 's/()//'
}


# =================================================================
#                       Applications
# =================================================================

app-running() {
    ps aux | grep -i "$1" >/dev/null
    if [[ $? == 0 ]]; then
        echo "yes"
    else
        echo "no"
    fi
}


# =================================================================
#                             Files
# =================================================================

# Just open the file as you can
open() {
    xdg-open "$1"
}
o() { open "$1" }

# Open text files in current terminal, other files separately
open_smart() {
    if [[ -f "$1" ]]; then
        name="$1"
        # make sure the access time of the file is updated
        touch -a -t $(date +%Y%m%d%H%M.%S) $name
        if file -L "$name" | grep -q text ; then
            # open text files in editor
            ${EDITOR:-vim} $name
        else
            # open separately, suppress output and don't exit when
            # parent terminal exits
            ( xdg-open "$name" &>/dev/null & )
        fi
    else
        notify-send -u low "open_smart" "No file called '$name' found."
    fi
}

# Open a document found in home and selected by fzf
open_doc() {
    local MAXDEPTH=6
    open_smart "$( find -L ~ \
        -maxdepth $MAXDEPTH \
        ! -path "*/\.*" -type f \
        -name "*.doc*" \
        -or -name "*.xls*" \
        -or -name "*.odt*" \
        -or -name "*.pdf*" \
        | fzf )" 
}
odoc() { open_doc "$1" }

# Open a text file found in home and selected by fzf
open_file() {
    local MAXDEPTH=4
    open_smart "$( find -L ~ \
        -maxdepth $MAXDEPTH \
        ! -path "*/\.*" \
        -type f \
        -exec grep -Iq . {} \; \
        -and -print \
        | fzf )"
}
of() { open_file "$1" }


# =================================================================
#                          Directories
# =================================================================

# Source http://seanbowman.me/blog/fzf-fasd-and-bash-aliases/

# Change (jump) to recent directory
j() {
    local dir="$(fasd -ld "$@")"
    [[ -d "$dir" ]] && pushd "$dir"
}

# Change to recent directory, select with fzf
jj() {
    local dir
    dir=$(fasd -Rdl |\
        sed "s:$HOME:~:" |\
        fzf --no-sort +m -q "$*" |\
        sed "s:~:$HOME:")\
    && pushd "$dir"
}

# Change to a subdirectory, select with fzf
jd() {
    local dir
    dir=$(find ${1:-*} -path '*/\.*'\
        -prune -o -type d\
        -print 2> /dev/null | fzf +m)
    [ -d "$dir" ] && pushd "$dir"
}

# Change to a subdirector which contains a given file, select with fzf
jf() {
    local file
    local dir
    file=$(fzf +m -q "$1")\
        && dir=$(dirname "$file")
    [ -d "$dir" ] && pushd "$dir"
}

# =================================================================
#                              Git
# =================================================================


# =================================================================
#                              Work
# =================================================================

# Interactively select a sql file with database connection
# Last edited files will be closer
# Using dbext in vim
dbext() {
    vim "$( ls --color=never --sort=time ~/work/db/*.sql | fzf )"
}

# =================================================================
#                          Improvements
# =================================================================

mvf() {
    dir="${@: -1}"
    tmp="$dir"; tmp="${tmp: -1}"
    [ "$tmp" != "/" ] && dir="$(dirname "$dir")"
    [ ! -d "$dir" ] ||
    mkdir -p "$dir" &&
    mv "$@"
}


# =================================================================
#                              Tmux
# =================================================================

# complete words from tmux pane(s) {{{1
# Source: http://blog.plenz.com/2012-01/zsh-complete-words-from-tmux-pane.html
_tmux_pane_words() {
  local expl
  local -a w
  if [[ -z "$TMUX_PANE" ]]; then
    _message "not running inside tmux!"
    return 1
  fi
  # capture current pane first
  w=( ${(u)=$(tmux capture-pane -J -p)} )
  for i in $(tmux list-panes -F '#P'); do
    # skip current pane (handled above)
    [[ "$TMUX_PANE" = "$i" ]] && continue
    w+=( ${(u)=$(tmux capture-pane -J -p -t $i)} )
  done
  _wanted values expl 'words from current tmux pane' compadd -a w
}

zle -C tmux-pane-words-prefix   complete-word _generic
zle -C tmux-pane-words-anywhere complete-word _generic
bindkey '^X^Tt' tmux-pane-words-prefix
bindkey '^X^TT' tmux-pane-words-anywhere
zstyle ':completion:tmux-pane-words-(prefix|anywhere):*' completer _tmux_pane_words
zstyle ':completion:tmux-pane-words-(prefix|anywhere):*' ignore-line current
# display the (interactive) menu on first execution of the hotkey
zstyle ':completion:tmux-pane-words-(prefix|anywhere):*' menu yes select interactive
zstyle ':completion:tmux-pane-words-anywhere:*' matcher-list 'b:=* m:{A-Za-z}={a-zA-Z}'
# }}}
#

# =================================================================
#                          Experimantal
# =================================================================

