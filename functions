#!/usr/bin/env zsh
#    __                      _    _
#   / _| _   _  _ __    ___ | |_ (_)  ___   _ __   ___
#  | |_ | | | || '_ \  / __|| __|| | / _ \ | '_ \ / __|
#  |  _|| |_| || | | || (__ | |_ | || (_) || | | |\__ \
#  |_|   \__,_||_| |_| \___| \__||_| \___/ |_| |_||___/
#

# =================================================================
#                         Utilities
# =================================================================

# Smart list function
# Lists directory contents, previews files, shows archive contents, or displays images
# Usage: l [path]
#   - No argument or directory: list directory contents with eza
#   - File (text): preview first 40 lines with batcat
#   - File (archive): list archive contents (zip, tar variants)
#   - File (image): render in terminal with icat
l() {
    local target="${1:-.}"

    if [[ -d "$target" ]]; then
        # Directory: use eza to list contents
        eval "$EZA_BASE_COMMAND --all \"$target\""
    elif [[ -f "$target" ]]; then
        local mime_type=$(file --mime-type -b "$target")

        # Check if it's an archive
        case "${target:l}" in
            *.zip)
                unzip -l "$target"
                ;;
            *.tar|*.tar.gz|*.tgz|*.tar.bz2|*.tbz2|*.tar.xz)
                tar -tvf "$target"
                ;;
            # Check if it's an image
            *.png|*.jpg|*.jpeg|*.gif|*.webp)
                # make the image fit in the terminal
                # use kitty image protocol to display it
                convert "$target" -resize 800x500 - | kitty +kitten icat
                ;;
            *)
                # Check MIME type for images (fallback)
                if [[ "$mime_type" =~ ^image/ ]]; then
                    # use kitty image protocol to display it
                    kitty +kitten icat "$target"
                else
                    # Regular file: preview with batcat (first 40 lines)
                    batcat --paging=never --line-range=:40 "$target"
                fi
                ;;
        esac
    else
        echo "Error: '$target' is not a valid file or directory"
        return 1
    fi
}

yes_or_no() {
    while true; do
        read yn"?$* [y/n]: "
        case $yn in
            [Yy]*) return 0  ;;
            [Nn]*) echo "Aborted" ; return  1 ;;
        esac
    done
}

# =================================================================
#                       Applications
# =================================================================

# Try to find word in dictionary, remove clutter from output
aj() {
    dict -d fd-eng-ces "$1" | grep -v '^From ' | grep -v '^\s*$' | grep -v "Entry edited" | grep -v '[0-9] def' | grep -v "$1" | sed 's/()//'
}

cs() {
    dict -d fd-ces-eng "$1" | grep -v '^From ' | grep -v '^\s*$' | grep -v "Entry edited" | sed 's/()//'
}

eng() {
    dict -d gcide "$1" | grep -v '^From ' | grep -v '^$' | sed 's/()//'
}

# Change current directory according to Ranger
ra() {
    tempfile="$(mktemp)"
    /usr/bin/ranger --choosedir="$tempfile" "${@:-$(pwd)}"
    test -f "$tempfile" &&
    if [ "$(cat -- "$tempfile")" != "$(echo -n `pwd`)" ]; then
        cd -- "$(cat "$tempfile")"
    fi
    rm -f -- "$tempfile"
}

# Browser history
bhistory() {
    local cols sep google_history open
    cols=$(( COLUMNS / 3 ))
    sep='{::}'

    google_history="$HOME/.config/google-chrome/Default/History"
    open=xdg-open
    cp -f "$google_history" /tmp/h
    sqlite3 -separator $sep /tmp/h \
        "select substr(title, 1, $cols), url
         from urls order by last_visit_time desc" | \
    awk -F $sep '{printf "%-'$cols's  \x1b[36m%s\x1b[m\n", $1, $2}' | \
    fzf --ansi --multi | sed 's#.*\(https*://\)#\1#' | xargs $open 2&>1 >/dev/null
}

fhistory() {
    local cols sep firefox_history open default_path
    cols=$(( COLUMNS / 3 ))
    sep='{::}'
    open=xdg-open
    
    # Get default profile path from profiles.ini
    default_path=$(grep -A3 "Profile0" ~/.mozilla/firefox/profiles.ini | grep "Path=" | cut -d'=' -f2)
    
    if [[ -z "$default_path" ]]; then
        echo "No default Firefox profile found"
        return 1
    fi
    
    firefox_history="$HOME/.mozilla/firefox/$default_path/places.sqlite"
    
    if [[ ! -f "$firefox_history" ]]; then
        echo "Firefox history not found at: $firefox_history"
        return 1
    fi
    
    cp -f "$firefox_history" /tmp/h
    sqlite3 -separator $sep /tmp/h \
        "select substr(moz_places.title, 1, $cols), moz_places.url
         from moz_places, moz_historyvisits 
         where moz_places.id = moz_historyvisits.place_id
         order by moz_historyvisits.visit_date desc" | \
    awk -F $sep '{printf "%-'$cols's  \x1b[36m%s\x1b[m\n", $1, $2}' | \
    fzf --ansi --multi | sed 's#.*\(https*://\)#\1#' | xargs $open 2&>1 >/dev/null
}

s() {
    local search
    search="$1"
    [ -z "$1" ] && read "search?Search: "
    ( node -pe "encodeURIComponent(\"$search\")" | xargs -I{} xdg-open "https://duckduckgo.com/?q={}" &>/dev/null & )
}


# =================================================================
#                             Files
# =================================================================

# Just open the file as you can
open() {
    ( xdg-open "$1" &>/dev/null & )
}

# Open text files in current terminal, other files separately
o() {
    if [[ -f "$1" ]]; then
        name="$1"
        # make sure the access time of the file is updated
        touch -a -t $(date +%Y%m%d%H%M.%S) $name
        if file -L "$name" | grep -q text ; then
            # open text files in editor
            ${EDITOR:-vim} $name
        else
            # open separately, suppress output and don't exit when
            # parent terminal exits
            ( xdg-open "$name" &>/dev/null & )
        fi
    elif [[ -d "$1" ]]; then
        ( xdg-open "$1" &>/dev/null & )
    else
        echo "No file called '$name' found."
    fi
}

# Extract any archive file
# Source https://github.com/xvoland/Extract
extract() {
	if [ -z "$1" ]; then
		# display usage if no parameters given
		echo "Usage: extract <path/file_name>.<zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz>"
	else
		if [ -f "$1" ] ; then
			local nameInLowerCase=`echo "$1" | awk '{print tolower($0)}'`
			case "$nameInLowerCase" in
				*.tar.bz2)   tar xvjf ./"$1"    ;;
				*.tar.gz)    tar xvzf ./"$1"    ;;
				*.tar.xz)    tar xvJf ./"$1"    ;;
				*.lzma)      unlzma ./"$1"      ;;
				*.bz2)       bunzip2 ./"$1"     ;;
				*.rar)       unrar x -ad ./"$1" ;;
				*.gz)        gunzip ./"$1"      ;;
				*.tar)       tar xvf ./"$1"     ;;
				*.tbz2)      tar xvjf ./"$1"    ;;
				*.tgz)       tar xvzf ./"$1"    ;;
				*.zip)       unzip ./"$1"       ;;
				*.Z)         uncompress ./"$1"  ;;
				*.7z)        7zr e ./"$1"       ;;
				*.xz)        unxz ./"$1"        ;;
				*.exe)       cabextract ./"$1"  ;;
				*)           echo "extract: '$1' - unknown archive method" ;;
			esac
		else
			echo "'$1' - file does not exist"
		fi
    fi
}
x() { extract "$1" }


# Edit file recently opened in neovim # file recent
file-recent() {
    local list file
    list=$(nvim --headless -u NONE -c 'echo v:oldfiles | q' 2>&1 | tr -d \' | tr -d '[]' | tr ',' '\n' | tr -d ' ' | grep -v '://' | grep -v '/\.local/' | grep -v '/tmp/' | sed "s:$HOME:~:" )
    file=$(echo $list | fzf --query="$1")
    file=$(echo $file | sed "s:~:$HOME:")
    if [ -n "$file" ]; then
        ${EDITOR:-vim} "$file" < /dev/tty
    fi
}
fe() { file-recent "$1" }

# Edit file in current (sub)dir with default editor (press Enter)
# or GUI application (press Ctrl+o)
file-edit() {
    local out file key
    IFS=$'\n' out=($(fd "$1" | fzf --expect=ctrl-o))
    key=$(head -1 <<< "$out")
    file=$(head -2 <<< "$out" | tail -1)
    if [ -n "$file" ]; then
        [ "$key" = ctrl-o ] && open "$file" || ${EDITOR:-vim} "$file" < /dev/tty
    fi
}

# Interactive search in files, open in vim on selected line
# Ignores lines not matching "\w"
file-search() {
    local out tokens file line
    out=$(rg --follow --no-heading "$1" | fzf)
    IFS=':' tokens=( $out )
    file=${tokens[1]}
    line=${tokens[2]}
    if [ -n "$out" ]; then
        ${EDITOR:-vim} "$file" +${line} +"setlocal cursorline" < /dev/tty
    fi
}

# Open a globally found file (via locate command)
file-locate() {
    local files
    file=$(locate -Ai -0 $@ | grep -z -vE '~$' | fzf --read0)
    if [[ -n $file ]]; then
        open_smart "$file"
    fi
}

# Trash restore
restore() {
    echo '' | trash-restore 2>/dev/null \
            | sed '$d' \
            | sort -k2,3 -k1,1n \
            | fzf \
            | awk 'END {print $1}' \
            | trash-restore >/dev/null 2>&1
}


# =================================================================
#                          Directories
# =================================================================

# Directories jumping
# Source http://seanbowman.me/blog/fzf-fasd-and-bash-aliases/

# Change to recent directory, select with fzf
dir-recent() {
    local dir
    dir=$(zoxide query --list |\
        sed "s:$HOME:~:" |\
        fzf --no-sort --query "$*" |\
        sed "s:~:$HOME:") \
    && cd "$dir"
}
dr() { dir-recent "$1" }

# Change to a subdirectory, select with fzf
dir-open() {
    local dir
    # dir=$(find -L ${1:-*} -path '*/\.*'\
    #     -prune -o -type d\
    #     -print 2> /dev/null | fzf)
    dir=$(fd --type=d | fzf)
    [ -d "$dir" ] && cd "$dir"
}
de() { dir-open "$1" }

# Change to a subdirectory which contains a given file, select with fzf
dir-with-file() {
    local file
    local dir
    file=$(fzf --query "$1")\
        && dir=$(dirname "$file")
    [ -d "$dir" ] && cd "$dir"
}

# Change to any directory or directory with file in it found by locate command
dir-locate() {
  local file
  file="$(locate -Ai -0 $@ | grep -z -vE '~$' | fzf --read0)"
  if [[ -n $file ]]; then
     if [[ -d $file ]]; then
        cd -- $file
     else
        cd -- ${file:h}
     fi
  fi
}


# =================================================================
#                              Git
# =================================================================

# Git status with fallback to file listing
gst() {
    if git rev-parse --git-dir > /dev/null 2>&1; then
        git status
    else
        echo "Not a git repository. Listing files instead:"
        EZA_COLORS=reset eza --all --long --git --no-user --group-directories-first --icons=auto --smart-group --time-style=relative --no-permissions
    fi
}

# Easy git commit
c() {
    IFS=' '
    git commit -m "${*}"
}

gac() { # git add and commit
    IFS=' '
    git add --all
    git commit -m "${*}"
}

ca() {
    IFS=' '
    git commit --amend -m "${*}"
}

ce() {
    IFS=' '
    git commit --allow-empty -m "${*}"
}

# Easy github issue
issue() {
    IFS=' '
    gh issue create --title "${*}"
}

# Searchable git log
fzf-log() {
  git log --graph --color=always \
      --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
  fzf --ansi --no-sort --reverse --tiebreak=index --bind=ctrl-s:toggle-sort \
      --bind "ctrl-m:execute:
                (grep -o '[a-f0-9]\{7\}' | head -1 |
                xargs -I % sh -c 'git show --color=always % | less -R') << 'FZF-EOF'
                {}
FZF-EOF"
}

# Checkout merge request from gitlab
mrco() {
  local out id
  out=$(glab mr list | grep '^!' | fzf --query "$1")
  if [ -n "$out" ]; then
    # id=$(echo $out | awk '{ print $1 }' | tr -d '!')
    branch=$(echo $out | awk -F '(' '{ print $3 }' | tr -d ')')
    glab mr checkout $branch
    yes_or_no "Unable to checkout $branch - force it?" &&
        git fetch --all &&
        git reset --hard origin/$branch &&
        git checkout $branch &&
        git pull
  fi
}

mrme() {
  local out id
  out=$(glab mr list | grep '^!' | fzf --query "$1")
  if [ -n "$out" ]; then
    id=$(echo $out | awk '{ print $1 }' | tr -d '!')
    glab mr merge --remove-source-branch --auto-merge --yes $id
  fi
}

mrmerge() {
    glab mr merge --remove-source-branch --auto-merge --yes
}

# List gitlab merge requests
mrs() {
    glab mr list
}


# =================================================================
#                              Code
# =================================================================

draft() {
    IFS=" "
    MY_SITE_DIR="${HOME}/code/lukastrumm"
    BLOG_DIR="src/_drafts"
    FILE_TITLE="${*}"
    FILE_SLUG=$(echo $FILE_TITLE | tr "[:upper:]" "[:lower:]" | sed "s/[[:space:]]\+/-/g")
    FILE_PATH="${MY_SITE_DIR}/${BLOG_DIR}/${FILE_SLUG}.md"
    echo "---" >> $FILE_PATH
    echo "title: ${FILE_TITLE}" >> $FILE_PATH
    echo "date: $(date +'%Y-%m-%d')" >> $FILE_PATH
    echo "tags: " >> $FILE_PATH
    echo "---" >> $FILE_PATH
    echo "" >> $FILE_PATH
    nvim "${FILE_PATH}" +"cd ${MY_SITE_DIR}"
}

blog() {
    IFS=" "
    MY_SITE_DIR="${HOME}/code/lukastrumm"
    BLOG_DIR="src/blog"
    FILE_TITLE="${*}"
    FILE_SLUG=$(echo $FILE_TITLE | tr "[:upper:]" "[:lower:]" | sed "s/[[:space:]]\+/-/g")
    FILE_PATH="${MY_SITE_DIR}/${BLOG_DIR}/${FILE_SLUG}.md"
    echo "---" >> $FILE_PATH
    echo "title: ${FILE_TITLE}" >> $FILE_PATH
    echo "date: $(date +'%Y-%m-%d')" >> $FILE_PATH
    echo "tags: " >> $FILE_PATH
    echo "---" >> $FILE_PATH
    echo "" >> $FILE_PATH
    nvim "${FILE_PATH}" +"cd ${MY_SITE_DIR}"
}

note() {
    IFS=" "
    MY_SITE_DIR="${HOME}/code/lukastrumm"
    NOTES_DIR="src/notes"
    FILE_TITLE="${*}"
    FILE_SLUG=$(echo $FILE_TITLE | tr "[:upper:]" "[:lower:]" | tr -d "!" | sed "s/[[:space:]]\+/-/g")
    FILE_PATH="${MY_SITE_DIR}/${NOTES_DIR}/${FILE_SLUG}.md"
    echo "---" >> $FILE_PATH
    echo "title: ${FILE_TITLE}" >> $FILE_PATH
    echo "date: $(date +'%Y-%m-%d')" >> $FILE_PATH
    echo "tags: " >> $FILE_PATH
    echo "---" >> $FILE_PATH
    echo "" >> $FILE_PATH
    nvim "${FILE_PATH}" +"cd ${MY_SITE_DIR}"
}

notes() {
    local out key relativePath webPath localPath url
    if [ -n "$1" ]; then
        IFS=$'\n' out=($(cd ~/code/lukastrumm/src; rg -t md "$1" | fzf --query "$1" --expect=ctrl-o))
    else
        IFS=$'\n' out=($(cd ~/code/lukastrumm/src; rg -t md -l "" | fzf --expect=ctrl-o))
    fi
    key=$(head -1 <<< "$out")
    relativePath=$(head -2 <<< "$out" | tail -1 | cut -f1 -d':')
    webPath=$(echo $relativePath | sed 's/\.md//')
    localPath="/home/lukas/code/lukastrumm/src/${relativePath}"
    url="https://lukastrumm.com/${webPath}"
    if [ -n "$relativePath" ]; then
        [ "$key" = ctrl-o ] && xdg-open "$url" &>/dev/null || ${EDITOR:-vim} "$localPath" < /dev/tty
    fi
}

# =================================================================
#                              Shell
# =================================================================

# Make directory, inform about the result and change current directory into it.
# Use only the first argument.
mkcd() {
    if [ ! -n "$1" ]; then
        echo "Enter a directory name"
    elif [ -d "$1" ]; then
        echo "'$1' already exists"
    else
        mkdir -pv "$1" && cd "$1" && echo "cd into: $1"
    fi
}

# Copy last command executed on command line into clipboard
last-command() {
    fc -l -1 | cut -d' ' -f4- | xsel --clipboard
}

# Print all executable files on path
executables() {
    echo -n "$PATH" \
        | xargs -d: -I{} -r -- \
        find -L {} -maxdepth 1 -mindepth 1 -type f -executable -printf '%P\n' \
        | sort -u
}

# Lists all functions available in shell
# Hack: using zsh array of functions, actually its keys (k),
# sorted (o). Filtering out internal functions (starting with _)
list-functions() {
    print -l ${(ok)functions} | grep -v '^_'
}

# Insert sequence `!!` which is expanded into output of last
# command by double Tab
insert-last-output() {
    xdotool type --clearmodifiers '`!!`' \
        && xdotool key --clearmodifiers Tab \
        && xdotool key --clearmodifiers Tab
}

# kill processes blocking ports
portkill() {
  local pid
  # get processes listening on local numbered ports and output process id, port number and process name
  pid=$( \
    netstat -tnlp 2>/dev/null \
    | awk 'BEGIN { OFS = "\t"; print "PID","PORT","NAME" } $4 ~ "(127.0.0.1\|\[::\]\|0.0.0.0):[0-9]" && $7!="-" { gsub(/:::/,":"); split($7,a,"/"); split($4,b,":"); print a[1],b[2],a[2] }' 2>/dev/null \
    | sort -n -k2 \
    | fzf \
    | awk '{ print $1 }' \
    )

  if [ "x$pid" != "x" ]; then
    echo $pid | xargs kill -${1:-9}
    echo "Process $pid was killed"
  else
    echo "No process was killed"
  fi
}

# zkill - kill processes - list only the ones you can kill.
zkill() {
    local pid
    if [ "$UID" != "0" ]; then
        pid=$(ps -f -u $UID | sed 1d | fzf -m | awk '{print $2}')
    else
        pid=$(ps -ef | sed 1d | fzf -m | awk '{print $2}')
    fi

    if [ "x$pid" != "x" ]; then
        echo $pid | xargs kill -${1:-9}
    fi
}

close_applications() {
    xdotool search --class ".*" | xargs -inum xdotool getwindowpid num 2> /dev/null | grep "^[0-9]" | uniq -u | xargs kill
}

# =================================================================
#                            Graphics
# =================================================================

vectorize() {
    local name
    name="$1"
    # https://linux.die.net/man/1/pdftoppm
    # http://potrace.sourceforge.net/potrace.1.html
    pdftoppm ${name}.pdf | potrace --output ${name}.svg --blacklevel 0.71 --color '#222020' --svg
}


# =================================================================
#                              Node
# =================================================================

latest-pnpm() {
    ls "$PNPM_HOME/.tools/@pnpm+linux-x64" | tr -d '/' | tr -d 'v' | sort --version-sort --reverse | head -n1
}

node-up() {
    fnm install --lts
    fnm use lts-latest
    node --version > .node-version
    echo "Now using $(node --version)"
    echo "Remember to check 'pnpm pkg get engines.node', nixpacks.toml, Dockerfiles, etc."
}

# =================================================================
#                              Work
# =================================================================

# Simple calculator
calc() {
    awk "BEGIN { print "$*" }"
}

# open files that has been modified in current repo
emod() {
    git status --porcelain | grep '^\(??\)\|\(M\)' | awk '{print $2}' | xargs ${EDITOR:-vim}
}

# =================================================================
#                          Experimantal
# =================================================================

# Translation tool
# https://github.com/soimort/translate-shell
t() {
    trans :cs -brief "${*}"
}

# English dictionary tool
# https://github.com/soimort/translate-shell
dic() {
    trans -d :en "${*}"
}
