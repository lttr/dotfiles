#!/usr/bin/env zsh
#    __                      _    _                    
#   / _| _   _  _ __    ___ | |_ (_)  ___   _ __   ___ 
#  | |_ | | | || '_ \  / __|| __|| | / _ \ | '_ \ / __|
#  |  _|| |_| || | | || (__ | |_ | || (_) || | | |\__ \
#  |_|   \__,_||_| |_| \___| \__||_| \___/ |_| |_||___/
#                                                      


# =================================================================
#                            Packages
# =================================================================

apt-list() {
    comm -23 <( apt-mark showmanual | sort -u ) <( gzip -dc /var/log/installer/initial-status.gz | sed -n 's/^Package: //p' | sort -u )
}


# =================================================================
#                          Dictionaries
# =================================================================

# Try to find word in dictionary, remove clutter from output

aj() {
    dict -d fd-eng-ces "$1" | grep -v '^From ' | grep -v '^$' | grep -v '[0-9] def' | grep -v "$1" | sed 's/()//'
}

cz() {
    dict -d fd-ces-eng "$1" | grep -v '^From ' | grep -v '^$' | sed 's/()//'
}

eng() {
    dict -d gcide "$1" | grep -v '^From ' | grep -v '^$' | sed 's/()//'
}


# =================================================================
#                       Applications
# =================================================================

# Change current directory according to Ranger
function rg {
    tempfile="$(mktemp)"
    /usr/bin/ranger --choosedir="$tempfile" "${@:-$(pwd)}"
    test -f "$tempfile" &&
    if [ "$(cat -- "$tempfile")" != "$(echo -n `pwd`)" ]; then
        cd -- "$(cat "$tempfile")"
    fi
    rm -f -- "$tempfile"
}


# =================================================================
#                             Files
# =================================================================

# Just open the file as you can
open() {
    xdg-open "$1" &>/dev/null &
}

# Open text files in current terminal, other files separately
open_smart() {
    if [[ -f "$1" ]]; then
        name="$1"
        # make sure the access time of the file is updated
        touch -a -t $(date +%Y%m%d%H%M.%S) $name
        if file -L "$name" | grep -q text ; then
            # open text files in editor
            ${EDITOR:-vim} $name
        else
            # open separately, suppress output and don't exit when
            # parent terminal exits
            ( xdg-open "$name" &>/dev/null & )
        fi
    elif [[ -d "$1" ]]; then
        ( xdg-open "$1" &>/dev/null & )
    else
        echo "No file called '$name' found."
    fi
}
o() { open_smart "$1" }

# Locate documents (pdfs, ms office, open doc)
locate_documents() {
    # only from /home/user folder, exclude hidden files in home folder
    # based on extension, with last character optional (like .docx)
    local RE="\/home\/$USER\/[^\.].*\.\(pdf\|doc\|xls\|ppt\|odt\|ods\|odp\).\?$"
    locate --ignore-case --regexp $RE
}
#
# Locate text files and scripts
locate_text_files() {
    # only from /home/user folder, exclude hidden files in home folder
    # based on extension
    local RE="\/home\/$USER\/[^\.].*\.\(txt\|md\|sh\|bash\|zsh\|conf\)$"
    locate --ignore-case --regexp $RE
}

# Open a document found in home and selected by fzf
open_doc() {
    open_smart "$(locate_documents | fzf)"
}

# Open a text file found in home and selected by fzf
open_file() {
    open_smart "$(locate_text_files | fzf)"
}

# Extract any archive file
# Source https://github.com/xvoland/Extract 
extract() {
	if [ -z "$1" ]; then
		# display usage if no parameters given
		echo "Usage: extract <path/file_name>.<zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz>"
	else
		if [ -f "$1" ] ; then
			local nameInLowerCase=`echo "$1" | awk '{print tolower($0)}'`
			case "$nameInLowerCase" in
				*.tar.bz2)   tar xvjf ./"$1"    ;;
				*.tar.gz)    tar xvzf ./"$1"    ;;
				*.tar.xz)    tar xvJf ./"$1"    ;;
				*.lzma)      unlzma ./"$1"      ;;
				*.bz2)       bunzip2 ./"$1"     ;;
				*.rar)       unrar x -ad ./"$1" ;;
				*.gz)        gunzip ./"$1"      ;;
				*.tar)       tar xvf ./"$1"     ;;
				*.tbz2)      tar xvjf ./"$1"    ;;
				*.tgz)       tar xvzf ./"$1"    ;;
				*.zip)       unzip ./"$1"       ;;
				*.Z)         uncompress ./"$1"  ;;
				*.7z)        7zr e ./"$1"       ;;
				*.xz)        unxz ./"$1"        ;;
				*.exe)       cabextract ./"$1"  ;;
				*)           echo "extract: '$1' - unknown archive method" ;;
			esac
		else
			echo "'$1' - file does not exist"
		fi
    fi
}
x() { extract "$1" }


# =================================================================
#                          Directories
# =================================================================

# Directories jumping
# Source http://seanbowman.me/blog/fzf-fasd-and-bash-aliases/

# Change to recent directory, select with fzf
jj() {
    local dir
    dir=$(fasd -Rdl |\
        sed "s:$HOME:~:" |\
        fzf --no-sort +m -q "$*" |\
        sed "s:~:$HOME:")\
    && pushd "$dir"
}

# Change to a subdirectory, select with fzf
jd() {
    local dir
    dir=$(find ${1:-*} -path '*/\.*'\
        -prune -o -type d\
        -print 2> /dev/null | fzf +m)
    [ -d "$dir" ] && pushd "$dir"
}

# Change to a subdirectory which contains a given file, select with fzf
jf() {
    local file
    local dir
    file=$(fzf +m -q "$1")\
        && dir=$(dirname "$file")
    [ -d "$dir" ] && pushd "$dir"
}

# =================================================================
#                             Files
# =================================================================

# Edit file recently opened in vim
ee() {
    local file
    local ctrlp_mru_cache=~/.cache/ctrlp/mru/cache.txt
    file=$(cat $ctrlp_mru_cache | fzf --query="$1" --exit-0)
    if [ -n "$file" ]; then
        vim "$file"
    fi
}

# Edit file in current (sub)dir with default editor (press Enter)
# or GUI application (press Ctrl+o)
fo() {
  local out file key
  IFS=$'\n' out=($(ag -g "$1" | fzf --exit-0 --expect=ctrl-o))
  key=$(head -1 <<< "$out")
  file=$(head -2 <<< "$out" | tail -1)
  if [ -n "$file" ]; then
    [ "$key" = ctrl-o ] && open "$file" || ${EDITOR:-vim} "$file"
  fi
}

# Interactive search in files, open in vim on selected line
# Ignores lines not matching "\w"
fa() {
    local out tokens file line
    out=$(ag --nobreak --noheading --nocolor "\w" . | fzf --exit-0)
    IFS=':' tokens=( $out )
    file=${tokens[1]}
    line=${tokens[2]}
    if [ -n "$out" ]; then
        vim "$file" +${line} +"setlocal cursorline"
    fi
}


# =================================================================
#                              Git
# =================================================================

# Easy git commit
c() {
    IFS=' '
    git commit -m "$*"
}

# =================================================================
#                              Work
# =================================================================

# Interactively select a sql file with database connection
# Last edited files will be closer
# Using dbext in vim
dbext() {
    vim "$( ls --color=never --sort=time ~/work/db/*.sql | fzf )"
}


# =================================================================
#                          Improvements
# =================================================================

# Make directory, inform about the result and change current directory into it.
# Use only the first argument.
mkcd() {
    if [ ! -n "$1" ]; then
        echo "Enter a directory name"
    elif [ -d "$1" ]; then
        echo "'$1' already exists"
    else
        mkdir -pv "$1" && cd "$1"
    fi
}


# =================================================================
#                              Tmux
# =================================================================

# complete words from tmux pane(s) {{{1
# Source: http://blog.plenz.com/2012-01/zsh-complete-words-from-tmux-pane.html
_tmux_pane_words() {
  local expl
  local -a w
  if [[ -z "$TMUX_PANE" ]]; then
    _message "not running inside tmux!"
    return 1
  fi
  # capture current pane first
  w=( ${(u)=$(tmux capture-pane -J -p)} )
  for i in $(tmux list-panes -F '#P'); do
    # skip current pane (handled above)
    [[ "$TMUX_PANE" = "$i" ]] && continue
    w+=( ${(u)=$(tmux capture-pane -J -p -t $i)} )
  done
  _wanted values expl 'words from current tmux pane' compadd -a w
}

zle -C tmux-pane-words-prefix   complete-word _generic
zle -C tmux-pane-words-anywhere complete-word _generic
bindkey '^X^Tt' tmux-pane-words-prefix
bindkey '^X^TT' tmux-pane-words-anywhere
zstyle ':completion:tmux-pane-words-(prefix|anywhere):*' completer _tmux_pane_words
zstyle ':completion:tmux-pane-words-(prefix|anywhere):*' ignore-line current
# display the (interactive) menu on first execution of the hotkey
zstyle ':completion:tmux-pane-words-(prefix|anywhere):*' menu yes select interactive
zstyle ':completion:tmux-pane-words-anywhere:*' matcher-list 'b:=* m:{A-Za-z}={a-zA-Z}'


# =================================================================
#                          Experimantal
# =================================================================

