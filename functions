#!/usr/bin/env zsh
#    __                      _    _                    
#   / _| _   _  _ __    ___ | |_ (_)  ___   _ __   ___ 
#  | |_ | | | || '_ \  / __|| __|| | / _ \ | '_ \ / __|
#  |  _|| |_| || | | || (__ | |_ | || (_) || | | |\__ \
#  |_|   \__,_||_| |_| \___| \__||_| \___/ |_| |_||___/
#                                                      


# =================================================================
#                       Applications
# =================================================================

# Try to find word in dictionary, remove clutter from output
aj() {
    dict -d fd-eng-ces "$1" | grep -v '^From ' | grep -v '^$' | grep -v '[0-9] def' | grep -v "$1" | sed 's/()//'
}

cz() {
    dict -d fd-ces-eng "$1" | grep -v '^From ' | grep -v '^$' | sed 's/()//'
}

eng() {
    dict -d gcide "$1" | grep -v '^From ' | grep -v '^$' | sed 's/()//'
}

# Change current directory according to Ranger
rg() {
    tempfile="$(mktemp)"
    /usr/bin/ranger --choosedir="$tempfile" "${@:-$(pwd)}"
    test -f "$tempfile" &&
    if [ "$(cat -- "$tempfile")" != "$(echo -n `pwd`)" ]; then
        cd -- "$(cat "$tempfile")"
    fi
    rm -f -- "$tempfile"
}

# Browse images
images() {
    feh \
        --image-bg black \
        --geometry 1600x1000 \
        --auto-zoom \
        --title "%u/%l | %n | %wx%h | %S" \
        --info ";indentify %F" \
        --hide-pointer \
        --action ";i3-msg 'workspace 6: ï‰¬ ' && gthumb %F >/dev/null 2>&1"
}

# Browser history
bhistory() {
    local cols sep google_history open
    cols=$(( COLUMNS / 3 ))
    sep='{::}'

    google_history="$HOME/.config/google-chrome/Default/History"
    open=xdg-open
    cp -f "$google_history" /tmp/h
    sqlite3 -separator $sep /tmp/h \
        "select substr(title, 1, $cols), url
         from urls order by last_visit_time desc" | \
    awk -F $sep '{printf "%-'$cols's  \x1b[36m%s\x1b[m\n", $1, $2}' | \
    fzf --ansi --multi | sed 's#.*\(https*://\)#\1#' | xargs $open 2&>1 >/dev/null
}


# =================================================================
#                             Files
# =================================================================

# Just open the file as you can
open() {
    xdg-open "$1" &>/dev/null &
}

# Open text files in current terminal, other files separately
open_smart() {
    if [[ -f "$1" ]]; then
        name="$1"
        # make sure the access time of the file is updated
        touch -a -t $(date +%Y%m%d%H%M.%S) $name
        if file -L "$name" | grep -q text ; then
            # open text files in editor
            ${EDITOR:-vim} $name
        else
            # open separately, suppress output and don't exit when
            # parent terminal exits
            ( xdg-open "$name" &>/dev/null & )
        fi
    elif [[ -d "$1" ]]; then
        ( xdg-open "$1" &>/dev/null & )
    else
        echo "No file called '$name' found."
    fi
}
o() { open_smart "$1" }

# Locate documents (pdfs, ms office, open doc)
locate_documents() {
    # only from /home/user folder, exclude hidden files in home folder
    # based on extension, with last character optional (like .docx)
    local RE="\/home\/$USER\/[^\.].*\.\(pdf\|doc\|xls\|ppt\|odt\|ods\|odp\).\?$"
    locate --ignore-case --regexp $RE
}
#
# Locate text files and scripts
locate_text_files() {
    # only from /home/user folder, exclude hidden files in home folder
    # based on extension
    local RE="\/home\/$USER\/[^\.].*\.\(txt\|md\|sh\|bash\|zsh\|conf\)$"
    locate --ignore-case --regexp $RE
}

# Open a document found in home and selected by fzf
open_doc() {
    open_smart "$(locate_documents | fzf)"
}

# Open a text file found in home and selected by fzf
open_file() {
    open_smart "$(locate_text_files | fzf)"
}

# Extract any archive file
# Source https://github.com/xvoland/Extract 
extract() {
	if [ -z "$1" ]; then
		# display usage if no parameters given
		echo "Usage: extract <path/file_name>.<zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz>"
	else
		if [ -f "$1" ] ; then
			local nameInLowerCase=`echo "$1" | awk '{print tolower($0)}'`
			case "$nameInLowerCase" in
				*.tar.bz2)   tar xvjf ./"$1"    ;;
				*.tar.gz)    tar xvzf ./"$1"    ;;
				*.tar.xz)    tar xvJf ./"$1"    ;;
				*.lzma)      unlzma ./"$1"      ;;
				*.bz2)       bunzip2 ./"$1"     ;;
				*.rar)       unrar x -ad ./"$1" ;;
				*.gz)        gunzip ./"$1"      ;;
				*.tar)       tar xvf ./"$1"     ;;
				*.tbz2)      tar xvjf ./"$1"    ;;
				*.tgz)       tar xvzf ./"$1"    ;;
				*.zip)       unzip ./"$1"       ;;
				*.Z)         uncompress ./"$1"  ;;
				*.7z)        7zr e ./"$1"       ;;
				*.xz)        unxz ./"$1"        ;;
				*.exe)       cabextract ./"$1"  ;;
				*)           echo "extract: '$1' - unknown archive method" ;;
			esac
		else
			echo "'$1' - file does not exist"
		fi
    fi
}
x() { extract "$1" }


# Edit file recently opened in vim # file recent
file-recent() {
    local out file key
    local ctrlp_mru_cache=~/.cache/ctrlp/mru/cache.txt
    file=$(cat $ctrlp_mru_cache | fzf --query="$1")
    if [ -n "$file" ]; then
        ${EDITOR:-vim} "$file" < /dev/tty
    fi
}
fr() { file-recent "$1" }

# Edit file in current (sub)dir with default editor (press Enter)
# or GUI application (press Ctrl+o)
file-edit() {
    local out file key
    IFS=$'\n' out=($(ag --follow -g "$1" | fzf --expect=ctrl-o))
    key=$(head -1 <<< "$out")
    file=$(head -2 <<< "$out" | tail -1)
    if [ -n "$file" ]; then
        [ "$key" = ctrl-o ] && open "$file" || ${EDITOR:-vim} "$file" < /dev/tty
    fi
}
fe() { file-edit "$1" }

# Interactive search in files, open in vim on selected line
# Ignores lines not matching "\w"
file-search() {
    local out tokens file line
    out=$(ag --follow --nobreak --noheading --nocolor "\w" . | fzf)
    IFS=':' tokens=( $out )
    file=${tokens[1]}
    line=${tokens[2]}
    if [ -n "$out" ]; then
        vim "$file" +${line} +"setlocal cursorline" < /dev/tty
    fi
}

# Open a globally found file (via locate command)
file-locate() {
    local files
    file=$(locate -Ai -0 $@ | grep -z -vE '~$' | fzf --read0)
    if [[ -n $file ]]; then
        open_smart "$file"
    fi
}



# =================================================================
#                          Directories
# =================================================================

# Directories jumping
# Source http://seanbowman.me/blog/fzf-fasd-and-bash-aliases/

# Change to recent directory, select with fzf
dir-recent() {
    local dir
    dir=$(fasd -Rdl |\
        sed "s:$HOME:~:" |\
        fzf --no-sort --query "$*" |\
        sed "s:~:$HOME:") \
    && cd "$dir"
    xdotool key KP_Enter
}
dr() { dir-recent "$1" }

# Change to a subdirectory, select with fzf
dir-open() {
    local dir
    dir=$(find -L ${1:-*} -path '*/\.*'\
        -prune -o -type d\
        -print 2> /dev/null | fzf)
    [ -d "$dir" ] && cd "$dir"
    xdotool key KP_Enter
}
de() { dir-open "$1" }

# Change to a subdirectory which contains a given file, select with fzf
dir-with-file() {
    local file
    local dir
    file=$(fzf --query "$1")\
        && dir=$(dirname "$file")
    [ -d "$dir" ] && cd "$dir"
}

# Change to any directory or directory with file in it found by locate command
dir-locate() {
  local file
  file="$(locate -Ai -0 $@ | grep -z -vE '~$' | fzf --read0)"
  if [[ -n $file ]]; then
     if [[ -d $file ]]; then
        cd -- $file
     else
        cd -- ${file:h}
     fi
  fi
}


# =================================================================
#                              Git
# =================================================================

# Easy git commit
c() {
    IFS=' '
    git commit -m "$*"
}

# Searchable git log
fzf-log() {
  git log --graph --color=always \
      --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
  fzf --ansi --no-sort --reverse --tiebreak=index --bind=ctrl-s:toggle-sort \
      --bind "ctrl-m:execute:
                (grep -o '[a-f0-9]\{7\}' | head -1 |
                xargs -I % sh -c 'git show --color=always % | less -R') << 'FZF-EOF'
                {}
FZF-EOF"
}


# =================================================================
#                              Shell
# =================================================================

# Make directory, inform about the result and change current directory into it.
# Use only the first argument.
mkcd() {
    if [ ! -n "$1" ]; then
        echo "Enter a directory name"
    elif [ -d "$1" ]; then
        echo "'$1' already exists"
    else
        mkdir -pv "$1" && cd "$1"
    fi
}

# Copy last command executed on command line into clipboard
last-command() {
    fc -l -1 | cut -d' ' -f4- | xsel --clipboard
}

# Print all executable files on path
executables() {
    echo -n "$PATH" \
        | xargs -d: -I{} -r -- \
        find -L {} -maxdepth 1 -mindepth 1 -type f -executable -printf '%P\n' \
        | sort -u
}

# Lists all functions available in shell
# Hack: using zsh array of functions, actually its keys (k),
# sorted (o). Filtering out internal functions (starting with _)
list-functions() {
    print -l ${(ok)functions} | grep -v '^_'
}


# =================================================================
#                              i3wm
# =================================================================

get-current-workspace-name() {
   i3-msg -t get_workspaces | jq -r '.[] | select(.focused==true).name'
}


# =================================================================
#                              Work
# =================================================================

# Interactively select a sql file with database connection
# Last edited files will be closer
# Using dbext in vim
dbext() {
    vim "$( ls --color=never --sort=time ~/work/db/*.sql | fzf )"
}


# =================================================================
#                              Tmux
# =================================================================

# complete words from tmux pane(s) {{{1
# Source: http://blog.plenz.com/2012-01/zsh-complete-words-from-tmux-pane.html
_tmux_pane_words() {
  local expl
  local -a w
  if [[ -z "$TMUX_PANE" ]]; then
    _message "not running inside tmux!"
    return 1
  fi
  # capture current pane first
  w=( ${(u)=$(tmux capture-pane -J -p)} )
  for i in $(tmux list-panes -F '#P'); do
    # skip current pane (handled above)
    [[ "$TMUX_PANE" = "$i" ]] && continue
    w+=( ${(u)=$(tmux capture-pane -J -p -t $i)} )
  done
  _wanted values expl 'words from current tmux pane' compadd -a w
}

zle -C tmux-pane-words-prefix   complete-word _generic
zle -C tmux-pane-words-anywhere complete-word _generic
bindkey '^X^Tt' tmux-pane-words-prefix
bindkey '^X^TT' tmux-pane-words-anywhere
zstyle ':completion:tmux-pane-words-(prefix|anywhere):*' completer _tmux_pane_words
zstyle ':completion:tmux-pane-words-(prefix|anywhere):*' ignore-line current
# display the (interactive) menu on first execution of the hotkey
zstyle ':completion:tmux-pane-words-(prefix|anywhere):*' menu yes select interactive
zstyle ':completion:tmux-pane-words-anywhere:*' matcher-list 'b:=* m:{A-Za-z}={a-zA-Z}'


# =================================================================
#                          Experimantal
# =================================================================

